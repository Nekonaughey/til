ブラウザ上で動くSPA、かつバックエンドありの前提で。

●ブラウザ上にセキュアに保存したい。
WebCryptoApi + IndexedDBが良いと思われる。
XSS脆弱性があったとしても、鍵の中身自体はextractされないようにできる


●鍵を複数本管理したい
鍵が複数本あると、端末移行時にすべての鍵を移行する必要がある。
なので、１本のマスターキーと、複数のサブキーに分けて管理して、
サブキーはマスターキーで暗号化して、バックエンドに保存しておくのが良いと思われる。
これで、マスターキーだけ移行すればサブキーは移行する必要がない。

●サブキーで使うアルゴリズム
この方法だと、サブキーはWebCryptoAPIを使う必要はない。

WebCryptoAPIはインタフェースが良くないと思う。
WebCryptoAPIを使うところは最小限にした方が良い。
後でライブラリを変えることが非常に困難になる。

JWKなどの標準的なフォーマットで管理されていれば何とでもなる。


●XSS脆弱性について
簡単な例だと、index.htmlに、
Scriptタグでサードパーティのライブラリを読み込んだ時点で、悪意があれば
localstorageもindexedbも全部触れる。

なので、サブキーをローカルに保存してはいけない。
XSS脆弱性があったらマスターキーで簡単に解かれる。

マスターキーすらWebCryptoAPIに依存したくないのが本音だが、
WebCryptoAPIでマスターキーを暗号化して、indexedDBに保存しておくと、
サブキーをローカルに保存するのと同じ脆弱性がある。


●サブキーの利用について
サブキーを使うときには結局バックエンドから取ってきた鍵をオンメモリに展開するわけだが、単純にGlobal変数やら、ReduxStoreやら、
JSからアクセスできるところに置いてあったらXSSで盗まれる可能性あり。

なので、Closureで包んで、sign, verify, encode, decodeだけできるようにするのが良いと思う。
ただし、WebCryptoAPIのCryptoKey型と違って、ClosureはIndexedDB等に保存できないので、
ClosureのままindexedDBに保存とかはできない。



●暗号化データのAPI連携
リソースオーナーはエンドユーザ自身であり、すべてのリソースはリソースオーナーの鍵で暗号化されるべき。
世の中のサービスはデータを活用するためだったりでそうはなっていないが。

そうすると、APIエコノミーなどの文脈では、他のサービスからデータを取ってきてもデータの中身が見れない。

これを実現するには以下のような方法の検討が必要
　１．鍵自体を第三者に公開する ⇒第三者に悪意があった場合、取り返しがつかない
　２．先に暗号化されていない公開用データを作ってもらう　⇒　ユーザの手間が増える。
　３．代理人再暗号で第三者が触れるデータを作る　⇒　データ自体は持っていかれても、鍵自体の流出は避けられる。データのコピーが必要。
　４．属性ベース暗号で第三者でも解けるようにする　⇒　データは１つで良くなる。権限はく奪とかどうやるのかよくわからない。
 
